<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kzfo - Owner of AK ADMIN</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">

    <!-- === XLSX SKRIPT === -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script type="text/javascript">
        // ... (Das XLSX Skript bleibt unverändert wie in der letzten Version) ...
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell != null && cell !== '';
        }
        function loadFileData(filename) {
          if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
              try {
                  if (typeof XLSX === 'undefined') {
                      console.error("XLSX library is not loaded!"); return "";
                  }
                  if (!gk_fileData[filename]) {
                      console.error("File data not found for:", filename); return "";
                  }
                  var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                  if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                      console.error("Workbook contains no sheets for:", filename); return "";
                  }
                  var firstSheetName = workbook.SheetNames[0];
                  var worksheet = workbook.Sheets[firstSheetName];
                  if (!worksheet) {
                      console.error("First worksheet is invalid for:", filename); return "";
                  }
                  var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                  var filteredData = jsonData.filter(row => row.some(filledCell));
                  if (filteredData.length === 0) {
                      console.warn("No non-empty rows found after filtering for:", filename); return "";
                  }
                  var headerRowIndex = filteredData.findIndex((row, index, arr) =>
                      index < arr.length - 1 &&
                      row.filter(filledCell).length >= arr[index + 1].filter(filledCell).length
                  );
                  if (headerRowIndex === -1 || headerRowIndex > 25) {
                      const firstNonEmptyRow = filteredData.findIndex(row => row.some(filledCell));
                      headerRowIndex = firstNonEmptyRow !== -1 ? firstNonEmptyRow : 0;
                  }
                  var dataToConvert = filteredData.slice(headerRowIndex);
                  if (!Array.isArray(dataToConvert) || dataToConvert.length === 0) {
                       console.warn("No data to convert after slicing header for:", filename); return "";
                  }
                  var csvSheet = XLSX.utils.aoa_to_sheet(dataToConvert);
                  var csv = XLSX.utils.sheet_to_csv(csvSheet, { FS: ',', RS: '\n' });
                  return csv;
              } catch (e) {
                  console.error("Error processing XLSX file:", filename, e); return "";
              }
          }
          return gk_fileData[filename] || "";
        }
    </script>
    <!-- === ENDE XLSX SKRIPT === -->

    <!-- === CSS === -->
    <style>
        /* ... (Das CSS bleibt unverändert wie in der letzten Version) ... */
        :root {
            --bg-primary: #000000;
            --bg-secondary: #1a0b2e;
            --bg-tertiary: #2a0f4e;
            --accent-primary: #6a11cb;
            --accent-secondary: #2575fc;
            --text-primary: #ffffff;
            --text-secondary: #c0c0ff;
            --card-bg: rgba(26, 11, 46, 0.75);
            --card-border: rgba(106, 17, 203, 0.55);
            --glow-color: rgba(106, 17, 203, 0.8);
            --shine-color: rgba(255, 255, 255, 0.13);
            --mouse-x: 50%;
            --mouse-y: 50%;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { cursor: none; }
        html, body {
            height: 100%; width: 100%; overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary), var(--bg-tertiary), var(--bg-secondary));
            background-size: 400% 400%; animation: gradientBG 25s ease infinite;
            color: var(--text-primary); position: relative;
        }
        @keyframes gradientBG {
           0%{background-position:0% 50%}
           50%{background-position:100% 50%}
           100%{background-position:0% 50%}
        }
        #cursor-dot {
            width: 8px; height: 8px; background-color: var(--accent-secondary);
            border-radius: 50%; position: fixed; top: 0; left: 0;
            transform: translate(-50%, -50%); pointer-events: none;
            z-index: 10000; transition: width 0.2s ease, height 0.2s ease, background-color 0.2s ease, transform 0.1s linear;
            mix-blend-mode: difference;
        }
        #interactive-background-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1;
            background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), rgba(106, 17, 203, 0.08) 0%, transparent 30%);
        }
        #threejs-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; display: block;
        }
        .profile-container {
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; text-align: center; perspective: 1800px;
            opacity: 0; transform: scale(0.9) translateY(30px);
            transition: opacity 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .profile-container.show { opacity: 1; transform: scale(1) translateY(0); }
        .profile-card {
             background: var(--card-bg); border-radius: 25px;
             backdrop-filter: blur(22px); border: 1px solid var(--card-border);
             padding: 2.5rem 3rem; width: 90%; max-width: 580px;
             transform-style: preserve-3d;
             transform: rotateX(10deg) rotateY(-12deg) scale(1);
             transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 0.4s ease;
             box-shadow: 0 30px 60px rgba(0,0,0,0.5);
             position: relative; overflow: hidden;
             animation: breathe 8s ease-in-out infinite alternate;
             will-change: transform, box-shadow;
        }
        @keyframes breathe {
            from { transform: rotateX(8deg) rotateY(-10deg) scale(1); box-shadow: 0 25px 50px rgba(0,0,0,0.45); }
            to { transform: rotateX(12deg) rotateY(-14deg) scale(1.02); box-shadow: 0 35px 70px rgba(0,0,0,0.55); }
        }
        .profile-card::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, var(--shine-color), transparent);
            transform: rotate(35deg); pointer-events: none; z-index: 1;
            opacity: 0; transition: opacity 0.4s ease;
        }
        .profile-card:hover::before { opacity: 1; }
        .profile-card:hover {
             box-shadow: 0 45px 90px rgba(0,0,0,0.75);
             transition: transform 0.08s linear, box-shadow 0.4s ease;
             animation-play-state: paused;
        }
        .profile-pic-container {
            width: 160px; height: 160px; margin: 0 auto 1.8rem auto; cursor: none;
            position: relative; transform-style: preserve-3d; z-index: 2;
            transform: translateZ(60px); will-change: transform;
        }
        .profile-pic {
            width: 100%; height: 100%; border-radius: 50%; object-fit: cover;
            border: 6px solid transparent;
            background: linear-gradient(70deg, var(--accent-primary), var(--accent-secondary));
            background-clip: padding-box; padding: 6px;
            box-shadow: 0 18px 36px rgba(0,0,0,0.4); display: block;
            transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 0.3s ease;
            position: absolute; top: 0; left: 0; will-change: transform;
        }
        .particle-burst {
             position: absolute; width: 8px; height: 8px;
             background: linear-gradient(45deg, var(--accent-primary), var(--accent-secondary), var(--text-primary));
             border-radius: 50%; top: 50%; left: 50%; pointer-events: none;
             opacity: 0.8; animation: burst 0.7s ease-out forwards; z-index: 5;
             will-change: transform, opacity;
        }
        @keyframes burst {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(var(--tx, 0), var(--ty, 0)) scale(0); opacity: 0; }
        }
        .username {
            font-family: 'Orbitron', sans-serif; font-size: 3rem; font-weight: 700; margin-bottom: 0.8rem;
            cursor: none; position: relative; display: inline-block; z-index: 2; transform: translateZ(60px);
            perspective: 500px; will-change: transform;
        }
        .username .char {
            display: inline-block;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), text-shadow 0.3s ease;
            background: linear-gradient(70deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px var(--glow-color); will-change: transform; transform: translateY(0) rotateX(0);
        }
        .username.wave-active .char { animation: wave-char 0.7s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes wave-char {
             0% { transform: translateY(0) rotateX(0); -webkit-text-fill-color: transparent; }
             40% { transform: translateY(-15px) rotateX(-35deg) scale(1.25); -webkit-text-fill-color: #fff; text-shadow: 0 10px 20px var(--glow-color); }
             70% { transform: translateY(3px) rotateX(5deg) scale(0.95); -webkit-text-fill-color: transparent; }
             100% { transform: translateY(0) rotateX(0); -webkit-text-fill-color: transparent; }
        }
        .typing-text { position: relative; display: inline-block; }
        .typing-text.typing::after {
            content: '|'; font-weight: 100; position: absolute; right: -0.2em;
            color: var(--accent-secondary); animation: typing-cursor 0.7s infinite;
        }
        @keyframes typing-cursor { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        .role {
            font-size: 1.6rem; margin-bottom: 1.2rem; color: var(--text-secondary);
            z-index: 2; transform: translateZ(60px); will-change: transform;
        }
        .gradient-text {
            background: linear-gradient(70deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold;
        }
        .role-link {
            color: var(--text-primary); text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
            position: relative; display: inline-block; font-weight: bold; margin-left: 6px; cursor: none;
        }
        .role-link::after {
            content: ''; position: absolute; width: 0; height: 2px; bottom: -6px; left: 50%;
            transform: translateX(-50%); background: linear-gradient(70deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.4s ease;
        }
        .role-link:hover { color: var(--accent-secondary); transform: translateY(-3px); }
        .role-link:hover::after { width: 100%; }
        .quote {
            font-style: italic; color: var(--text-secondary); margin: 1.8rem 0;
            opacity: 0.9; font-size: 1rem; max-width: 85%; margin-left: auto; margin-right: auto;
            z-index: 2; transform: translateZ(60px); will-change: transform;
        }
        .social-links {
            display: flex; justify-content: center; gap: 2.5rem; margin-top: 2.5rem;
            z-index: 2; transform: translateZ(60px); will-change: transform;
        }
        .social-icon {
            color: var(--text-secondary); font-size: 2rem;
            transition: color 0.3s ease, opacity 0.3s ease, transform 0.15s linear;
            opacity: 0.8; will-change: transform; cursor: none;
        }
        .social-icon:hover { color: var(--text-primary); opacity: 1; }
        .intro-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            display: flex; align-items: center; justify-content: center; z-index: 9999;
            opacity: 1; transition: opacity 1.5s ease, transform 1.5s ease;
        }
        .intro-overlay.hide { opacity: 0; transform: scale(1.1); pointer-events: none; }
        .intro-overlay .typing-text {
            font-family: 'Orbitron', sans-serif; font-size: clamp(3rem, 10vw, 6rem); font-weight: 700;
            background: linear-gradient(45deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }
        @media (max-width: 640px) {
            /* ... (Media Queries unverändert) ... */
            .profile-card { padding: 2rem 1.5rem; animation: breathe-mobile 8s ease-in-out infinite alternate; }
            .profile-pic-container { width: 120px; height: 120px; margin-bottom: 1.5rem; }
            .username { font-size: 2.2rem; }
            .role { font-size: 1.3rem; }
            .quote { font-size: 0.9rem; }
            .social-links { gap: 2rem; }
            .social-icon { font-size: 1.8rem; }
            @keyframes breathe-mobile {
               from { transform: rotateX(5deg) rotateY(-5deg) scale(1); box-shadow: 0 15px 30px rgba(0,0,0,0.4); }
               to { transform: rotateX(7deg) rotateY(-7deg) scale(1.01); box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
            }
        }
    </style>
    <!-- === ENDE CSS === -->
</head>
<body>
    <!-- Elemente für Effekte -->
    <div id="cursor-dot"></div>
    <div id="interactive-background-layer"></div>
    <canvas id="threejs-canvas"></canvas>

    <!-- Intro Overlay -->
    <div class="intro-overlay">
        <div class="typing-text typing" id="intro-typing"></div>
    </div>

    <!-- Hauptinhalt -->
    <div class="profile-container" id="profile-container">
        <div class="profile-card" id="profile-card">
            <div class="profile-pic-container" id="profile-pic-container">
                 <img src="https://cdn.discordapp.com/avatars/913416953555722250/74fa4dd169974d73b6f59a58db445f06.png?size=4096" alt="Profilbild von Kzfo" class="profile-pic" id="profile-pic">
            </div>
            <div class="username" id="username-container" onclick="window.open('https://discord.com/users/913416953555722250', '_blank')" style="cursor: none;">
                <span class="typing-text" id="username-typing"></span>
            </div>
            <div class="role">
                <span id="owner-text" class="gradient-text typing-text"></span>
                <a href="https://discord.gg/akadmin" target="_blank" class="role-link typing-text" id="ak-admin-link"></a>
            </div>
            <div class="quote typing-text" id="quote-typing"></div>
            <div class="social-links" id="social-links">
                <a href="https://discord.gg/akadmin" target="_blank" class="social-icon" aria-label="Discord Server">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5116.074.074 0 00-.0079.0394c-.211.3755-.4447.8651-.6094 1.2468-1.8207-.2725-3.6386-.2725-5.4469 0-.1647-.3817-.4006-.8713-.6129-1.2468a.077.077 0 00-.0079-.0394 19.7859 19.7859 0 00-4.8851 1.5116a.0697.0697 0 00-.0321.0273C.5334 9.0196-.319 13.5910.0992 18.0958a.0825.0825 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0084-.0273c.4604-.6279.8697-1.2905 1.2275-1.9963a.076.076 0 00-.0415-.1061c-.6549-.2477-1.2785-.5507-1.8771-.8919a.077.077 0 01-.0076-.1277c.1258-.0943.2539-.1923.3773-.2912a.0743.0743 0 01.0777-.0105c3.9923 1.8188 8.3188 1.8188 12.2513 0a.0736.0736 0 01.0777.0105c.1234.0989.2514.1969.3773.2912a.077.077 0 01-.0066.1277c-.6092.3494-1.2314.6404-1.8794.8919a.0762.0762 0 00-.0407.1073c.3598.7058.7692 1.3684 1.2275 1.9963a.0765.0765 0 00.0084.0273c1.9545-.6066 3.9431-1.5218 6.0028-3.0294a.077.077 0 00.0313-.0561c.4548-5.1382-.7614-9.6526-3.21-13.6232a.061.061 0 00-.0312-.0274z"/>
                    </svg>
                </a>
            </div>
        </div>
    </div>

    <!-- Audio Element -->
    <audio id="background-music" loop>
        <source src="chill-galaxy-melody.mp3" type="audio/mpeg">
        Dein Browser unterstützt das Audio-Element nicht.
    </audio>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Haupt-JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elemente auswählen ---
            // ... (bleibt gleich) ...
            const cursorDot = document.getElementById('cursor-dot');
            const interactiveBgLayer = document.getElementById('interactive-background-layer');
            const introOverlay = document.querySelector('.intro-overlay');
            const introTypingEl = document.getElementById('intro-typing');
            const profileContainer = document.getElementById('profile-container');
            const profileCard = document.getElementById('profile-card');
            const profilePicContainer = document.getElementById('profile-pic-container');
            const profilePic = document.getElementById('profile-pic');
            const usernameContainer = document.getElementById('username-container');
            const usernameTypingEl = document.getElementById('username-typing');
            const ownerTextEl = document.getElementById('owner-text');
            const akAdminLinkEl = document.getElementById('ak-admin-link');
            const quoteEl = document.getElementById('quote-typing');
            const socialLinksContainer = document.getElementById('social-links');
            const socialIcons = socialLinksContainer ? socialLinksContainer.querySelectorAll('.social-icon') : [];
            const threeJsCanvas = document.getElementById('threejs-canvas');
            const audio = document.getElementById('background-music');

            // --- Globale Variablen ---
            // ... (bleibt gleich) ...
            let mouse = new THREE.Vector2(-10, -10);
            let targetMouse = new THREE.Vector2(-10,-10);
            const parallaxFactorCard = 0.08;
            const parallaxFactorIcons = 0.15;
            let threeJsInitialized = false;
            let animationFrameIdMain = null;
            let animationFrameIdSocial = null;
            let isWaveAnimationRunning = false;

            // --- Audio abspielen ---
            // ... (bleibt gleich) ...
            if (audio) {
                audio.volume = 0.2;
                audio.play().catch(error => {
                    console.log('Musik Autoplay blockiert, Nutzer muss interagieren:', error.name, error.message);
                    const startAudioOnInteraction = () => {
                         audio.play().then(() => {
                             console.log("Musik spielt nach Interaktion.");
                             document.removeEventListener('click', startAudioOnInteraction);
                             document.removeEventListener('keydown', startAudioOnInteraction);
                             document.removeEventListener('touchstart', startAudioOnInteraction);
                         }).catch(err => console.error("Fehler beim Starten der Musik nach Interaktion:", err));
                    };
                    document.addEventListener('click', startAudioOnInteraction, { once: true });
                    document.addEventListener('keydown', startAudioOnInteraction, { once: true });
                    document.addEventListener('touchstart', startAudioOnInteraction, { once: true });
                });
            }

            // --- Custom Cursor ---
            // ... (bleibt gleich) ...
            if (cursorDot) {
                window.addEventListener('mousemove', (e) => {
                     cursorDot.style.left = `${e.clientX}px`;
                     cursorDot.style.top = `${e.clientY}px`;
                     targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                     targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }, { passive: true });
                 document.querySelectorAll('a, button, [onclick], .profile-pic-container').forEach(el => {
                     el.addEventListener('mouseenter', () => cursorDot.style.transform = 'translate(-50%, -50%) scale(2.5)');
                     el.addEventListener('mouseleave', () => cursorDot.style.transform = 'translate(-50%, -50%) scale(1)');
                 });
            } else { document.documentElement.style.cursor = 'auto'; }

            // --- Mauspositions-Listener für Aura ---
             // ... (bleibt gleich) ...
             window.addEventListener('mousemove', (e) => {
                 const mouseXPerc = (e.clientX / window.innerWidth) * 100;
                 const mouseYPerc = (e.clientY / window.innerHeight) * 100;
                 document.documentElement.style.setProperty('--mouse-x', `${mouseXPerc}%`);
                 document.documentElement.style.setProperty('--mouse-y', `${mouseYPerc}%`);
            }, { passive: true });

            // --- Text Tipp-Animation Funktion ---
            // ... (bleibt gleich) ...
            function typeText(element, text, delay = 80, callback = null) {
                 if (!element) { console.error("Typing element not found for text:", text); if(callback) callback(new Error("Element not found")); return; }
                 let currentContent = ''; element.textContent = ''; element.classList.add('typing');
                 let index = 0; let typingInterval = null;
                 function type() {
                     try {
                         if (index < text.length) {
                             currentContent += text.charAt(index); element.textContent = currentContent;
                             index++; typingInterval = setTimeout(type, delay + Math.random() * 30 - 15);
                         } else { element.classList.remove('typing'); if (callback) callback(); }
                     } catch (error) {
                          console.error("Error during typing:", error, "on element:", element); element.classList.remove('typing'); if (callback) callback(error);
                     }
                 }
                 if (typingInterval) clearTimeout(typingInterval); typingInterval = setTimeout(type, delay);
             }

            // --- Benutzername Interaktivität ---
             // ... (bleibt gleich) ...
            function setupInteractiveUsername(usernameText) {
                 if (!usernameTypingEl || !usernameContainer) { console.warn("Username elements for interaction not found."); return; }
                 usernameTypingEl.innerHTML = usernameText.split('').map(char => `<span class="char">${char === ' ' ? ' ' : char}</span>`).join('');
                 const chars = usernameTypingEl.querySelectorAll('.char');
                 usernameContainer.addEventListener('mouseenter', () => {
                     if (isWaveAnimationRunning) return; isWaveAnimationRunning = true; usernameContainer.classList.add('wave-active');
                     chars.forEach((char, index) => { char.style.animationDelay = `${index * 0.05}s`; });
                     const totalDuration = 700 + (chars.length - 1) * 50;
                     setTimeout(() => { usernameContainer.classList.remove('wave-active'); chars.forEach(char => char.style.animationDelay = ''); isWaveAnimationRunning = false; }, totalDuration);
                 });
             }

            // --- Intro Animation ---
             // ... (bleibt gleich) ...
            function startIntroAnimation() {
                 if (!introTypingEl || !introOverlay || !profileContainer || !usernameTypingEl || !ownerTextEl || !akAdminLinkEl || !quoteEl) {
                     console.error("Ein oder mehrere UI-Elemente für die Intro-Animation fehlen! Stoppe Animation.");
                     if (introOverlay) introOverlay.classList.add('hide'); if (profileContainer) profileContainer.classList.add('show'); return;
                 }
                 const introText = 'Kzfo'; console.log("Starte Intro Tipp-Animation...");
                 typeText(introTypingEl, introText, 150, (introError) => {
                     console.log("Intro Tippen beendet.", introError || "Erfolgreich.");
                     setTimeout(() => {
                         introOverlay.classList.add('hide'); profileContainer.classList.add('show'); console.log("Intro ausgeblendet, Profil eingeblendet.");
                         if (!introError) {
                            console.log("Starte Profil Tipp-Sequenz...");
                            typeText(usernameTypingEl, 'Kzfo', 100, (userError) => {
                                if (userError) console.error("Fehler beim Tippen des Usernamens:", userError); else setupInteractiveUsername('Kzfo');
                                setTimeout(() => {
                                    typeText(ownerTextEl, 'Owner of ', 80, (ownerError) => {
                                        if (ownerError) console.error("Fehler beim Tippen von 'Owner of':", ownerError);
                                        setTimeout(() => {
                                            typeText(akAdminLinkEl, 'AK ADMIN', 80, (linkError) => {
                                                 if (linkError) console.error("Fehler beim Tippen von 'AK ADMIN':", linkError);
                                                 setTimeout(() => {
                                                     typeText(quoteEl, '"In the midst of chaos, there is also opportunity." - Sun Tzu', 50, (quoteError) => {
                                                         if(quoteError) console.error("Fehler beim Tippen des Zitats:", quoteError); console.log("Profil Tipp-Sequenz beendet.");
                                                     });
                                                 }, 300); });
                                        }, 150); });
                                }, 500); });
                         } else {
                              console.warn("Überspringe Profil-Tippen wegen Fehler im Intro-Tippen.");
                              if(usernameTypingEl) usernameTypingEl.textContent = 'Kzfo'; setupInteractiveUsername('Kzfo');
                              if(ownerTextEl) ownerTextEl.textContent = 'Owner of '; if(akAdminLinkEl) akAdminLinkEl.textContent = 'AK ADMIN';
                              if(quoteEl) quoteEl.textContent = '"In the midst of chaos, there is also opportunity." - Sun Tzu';
                         }
                     }, 700); });
            }

            // --- Partikel-Burst ---
             // ... (bleibt gleich) ...
             function createParticleBurst(event) {
                if (!profilePicContainer) return; const rect = profilePicContainer.getBoundingClientRect();
                const clickX = event.clientX - rect.left - rect.width / 2; const clickY = event.clientY - rect.top - rect.height / 2;
                const angleOffset = Math.atan2(clickY, clickX);
                for (let i = 0; i < 25; i++) {
                    const particle = document.createElement('div'); particle.classList.add('particle-burst');
                    const angle = angleOffset + (Math.random() - 0.5) * Math.PI * 0.8; const distance = 50 + Math.random() * 80;
                    const tx = `${Math.cos(angle) * distance}px`; const ty = `${Math.sin(angle) * distance}px`;
                    particle.style.setProperty('--tx', tx); particle.style.setProperty('--ty', ty);
                    particle.style.animationDuration = `${0.5 + Math.random() * 0.4}s`;
                    profilePicContainer.appendChild(particle); particle.addEventListener('animationend', () => particle.remove(), { once: true });
                }
            }
            if (profilePicContainer) { profilePicContainer.addEventListener('click', createParticleBurst); }

            // --- Interaktive 3D-Karte ---
            // ... (bleibt gleich) ...
            if (profileCard) {
                 profileCard.addEventListener('mousemove', (e) => {
                     const rect = profileCard.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
                     const centerX = rect.width / 2; const centerY = rect.height / 2;
                     const rotateX = (y - centerY) / centerY * -12; const rotateY = (x - centerX) / centerX * 12;
                     profileCard.style.transform = `perspective(1800px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.03)`;
                 }, { passive: true });
                 profileCard.addEventListener('mouseleave', () => {
                     profileCard.style.transition = 'transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 0.4s ease'; profileCard.style.transform = '';
                     setTimeout(() => { profileCard.style.transition = ''; }, 600);
                 });
             }

            // --- Reaktive Social Icons ---
            // ... (bleibt gleich) ...
            function updateSocialIcons() {
                 if (!socialIcons || socialIcons.length === 0 || !threeJsInitialized) {
                    if (animationFrameIdSocial) cancelAnimationFrame(animationFrameIdSocial); animationFrameIdSocial = null; return;
                 }
                 const lerpedMouseX = mouse.x; const lerpedMouseY = mouse.y;
                 const mouseOffsetX = (lerpedMouseX / 2) * window.innerWidth / 4; const mouseOffsetY = (lerpedMouseY / 2) * window.innerHeight / 4;
                 socialIcons.forEach(icon => {
                     const moveX = -mouseOffsetX * parallaxFactorIcons; const moveY = -mouseOffsetY * parallaxFactorIcons;
                     icon.style.transform = `translate(${moveX}px, ${moveY}px)`;
                 });
                 animationFrameIdSocial = requestAnimationFrame(updateSocialIcons);
            }

            // ===============================================================
            // ===== THREE.JS SETUP - MODIFIZIERT FÜR 3D EFFEKTE ===========
            // ===============================================================
            let scene, camera, renderer, particles, particleGeometry, particleMaterial;
            let particleVelocities = [];
            let particleColors = []; // NEU: Für Vertex Colors
            let particleData = [];   // NEU: Für individuelle Bewegung (Phase, Speed)
            const PARTICLE_COUNT = 2500; // Etwas mehr Partikel vielleicht?
            const particleInteractionRadiusSq = 1.8 * 1.8;
            const particleRepulsionForce = 0.0018;
            const particleDamping = 0.96;
            const particleBaseSpeed = 0.00005; // Basis-Drift etwas langsamer
            const spread = 22; // Etwas weiter verteilt

            // NEU: Sternschnuppen-Parameter
            let shootingStarInterval = 4; // Sekunden zwischen Versuchen
            let lastShootingStarTime = 0;
            let shootingStarDuration = 0.6; // Wie lange sie schnell ist
            let shootingStarSpeedBoost = 0.8; // Wie schnell sie ist
            let activeShootingStars = {}; // Speichert Index und Endzeit { index: endTime }

            function initThreeJS() {
                console.log("Initialisiere Three.js (mit 3D Effekten)...");
                if (!threeJsCanvas) { console.error("Three.js Canvas Element nicht gefunden!"); return false; }

                try {
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 8; // Bisschen weiter weg für mehr Tiefenwirkung

                    const context = threeJsCanvas.getContext('webgl') || threeJsCanvas.getContext('experimental-webgl');
                    if (!context) {
                       console.error("WebGL wird nicht unterstützt oder ist deaktiviert.");
                       threeJsCanvas.style.display = 'none'; return false;
                    }

                    renderer = new THREE.WebGLRenderer({ canvas: threeJsCanvas, context: context, alpha: true, antialias: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.setClearAlpha(0);

                    particleGeometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(PARTICLE_COUNT * 3);
                    const colors = new Float32Array(PARTICLE_COUNT * 3); // Array für Farben
                    particleVelocities = []; // Reset
                    particleData = [];     // Reset

                    const baseColor = new THREE.Color(0x9090FF); // Basis-Farbe (helles Lila/Blau)

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;

                        // Position
                        positions[i3] = (Math.random() - 0.5) * spread;
                        positions[i3 + 1] = (Math.random() - 0.5) * spread;
                        positions[i3 + 2] = (Math.random() - 0.5) * spread; // Auch in Z verteilen

                        // Velocity
                        particleVelocities.push(new THREE.Vector3(
                            (Math.random() - 0.5) * particleBaseSpeed * 10,
                            (Math.random() - 0.5) * particleBaseSpeed * 10,
                            (Math.random() - 0.5) * particleBaseSpeed * 10
                        ));

                        // Color (Vertex Colors)
                        const particleColor = baseColor.clone();
                        // Leichte Variation in Helligkeit und Sättigung
                        particleColor.offsetHSL(
                            (Math.random() - 0.5) * 0.1,  // Hue leicht variieren
                            (Math.random() - 0.5) * 0.1,  // Saturation leicht variieren
                            (Math.random() - 0.5) * 0.3   // Lightness stärker variieren
                         );
                        colors[i3] = particleColor.r;
                        colors[i3 + 1] = particleColor.g;
                        colors[i3 + 2] = particleColor.b;

                        // Zusätzliche Daten für individuelle Bewegung
                        particleData.push({
                            phase: Math.random() * Math.PI * 2,         // Startwinkel
                            speed: (Math.random() * 0.5 + 0.2) * 0.5, // Geschwindigkeit der Kreisbewegung
                            radius: Math.random() * 0.03 + 0.01        // Radius der Kreisbewegung (sehr klein!)
                        });
                    }

                    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); // Farb-Attribut setzen

                    particleMaterial = new THREE.PointsMaterial({
                        size: 0.045, // Größe leicht angepasst
                        // color: 0xffffff, // Basis-Farbe nicht mehr nötig, da Vertex Colors aktiv
                        vertexColors: true, // WICHTIG: Vertex Colors aktivieren!
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.8, // Etwas höhere Opazität
                        map: createCircleTexture(),
                        blending: THREE.AdditiveBlending
                    });

                    particles = new THREE.Points(particleGeometry, particleMaterial);
                    scene.add(particles);

                    console.log("Three.js Szene erfolgreich erstellt (mit Vertex Colors & Partikeldaten).");

                    window.addEventListener('resize', onWindowResize, false);
                    threeJsInitialized = true;
                    return true;

                } catch (error) {
                    console.error("Schwerer Fehler bei der Three.js Initialisierung:", error);
                    if (threeJsCanvas) threeJsCanvas.style.display = 'none';
                    threeJsInitialized = false;
                    scene = undefined; camera = undefined; renderer = undefined; particles = undefined; particleGeometry = undefined;
                    return false;
                }
            }

            function createCircleTexture() {
                // ... (bleibt gleich) ...
                const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
                const context = canvas.getContext('2d'); if (!context) return null;
                context.beginPath(); context.arc(16, 16, 15, 0, Math.PI * 2);
                context.fillStyle = 'white'; context.fill();
                return new THREE.CanvasTexture(canvas);
            }

            function onWindowResize() {
                // ... (bleibt gleich) ...
                if (!threeJsInitialized || !camera || !renderer) return;
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                console.log("Three.js Größe angepasst.");
            }

            const clock = new THREE.Clock();
            const raycaster = new THREE.Raycaster();
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const mouseWorldPos = new THREE.Vector3();
            const tempParticlePos = new THREE.Vector3(); // Hilfsvektor

            // Three.js Animations-Loop - MODIFIZIERT
            function animateThreeJS() {
                if (!threeJsInitialized || !scene || !camera || !renderer || !particles || !particleGeometry || !particleGeometry.attributes || !particleGeometry.attributes.position || !clock || !particleVelocities || !particleData) {
                     console.warn("Three.js Animations-Loop gestoppt: Eine Kernkomponente fehlt.");
                     if (animationFrameIdMain) { cancelAnimationFrame(animationFrameIdMain); animationFrameIdMain = null; } return;
                }

                animationFrameIdMain = requestAnimationFrame(animateThreeJS);
                const delta = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();

                try {
                    mouse.lerp(targetMouse, 0.06);

                    // Kamera Bewegung
                    const targetCameraX = mouse.x * 1.0; // Etwas stärkere Bewegung für mehr Effekt
                    const targetCameraY = mouse.y * 1.0;
                    camera.position.lerp(new THREE.Vector3(targetCameraX, targetCameraY, camera.position.z), 0.035); // Etwas schneller
                    if(scene.position) { camera.lookAt(scene.position); }

                    // Update Plane
                    plane.constant = -camera.position.z + 1;

                    // Mausposition in 3D
                    raycaster.setFromCamera(mouse, camera);
                    if (!raycaster.ray.intersectPlane(plane, mouseWorldPos)) {
                        mouseWorldPos.set(mouse.x * (spread/1.5), mouse.y * (spread/1.5), 0);
                    }

                    // --- Sternschnuppen Logik ---
                    if (elapsedTime - lastShootingStarTime > shootingStarInterval * (0.5 + Math.random())) { // Intervall leicht zufällig
                        const starCount = Math.floor(Math.random() * 3) + 1; // 1-3 Sternschnuppen gleichzeitig
                        for (let k=0; k<starCount; k++) {
                            const index = Math.floor(Math.random() * PARTICLE_COUNT);
                            // Nur starten, wenn nicht schon aktiv
                            if (activeShootingStars[index] === undefined) {
                                const direction = new THREE.Vector3(
                                    (Math.random() - 0.5) * 2,
                                    (Math.random() - 0.5) * 2,
                                    (Math.random() - 0.5) * 0.5 // Weniger stark in Z-Richtung
                                ).normalize();
                                particleVelocities[index].copy(direction).multiplyScalar(shootingStarSpeedBoost);
                                activeShootingStars[index] = elapsedTime + shootingStarDuration * (0.8 + Math.random() * 0.4); // Dauer leicht zufällig
                                // Optional: Farbe heller machen (geht nicht direkt mit vertexColors leicht)
                            }
                        }
                        lastShootingStarTime = elapsedTime;
                    }


                    // --- Partikel updaten ---
                    const positions = particleGeometry.attributes.position.array;
                    if (!positions || positions.length !== PARTICLE_COUNT * 3) { /* ... Fehlerbehandlung ... */ return; }

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        tempParticlePos.fromArray(positions, i3); // Aktuelle Position laden
                        const velocity = particleVelocities[i];
                        const data = particleData[i]; // Zusätzliche Bewegungsdaten

                        const isShootingStar = activeShootingStars[i] !== undefined;

                        // 1. Maus Interaktion (wirkt immer)
                        const distanceToMouseSq = tempParticlePos.distanceToSquared(mouseWorldPos);
                        if (distanceToMouseSq < particleInteractionRadiusSq) {
                            const repelDir = tempParticlePos.clone().sub(mouseWorldPos).normalize();
                            const repelStrength = (particleInteractionRadiusSq - distanceToMouseSq) / particleInteractionRadiusSq;
                            velocity.add(repelDir.multiplyScalar(particleRepulsionForce * Math.max(0, repelStrength) * delta * 60));
                        }

                        // 2. Individuelle Bewegung (nur wenn *keine* Sternschnuppe)
                        if (!isShootingStar) {
                            data.phase += data.speed * delta;
                            // Kleine Kreisbewegung auf XY-Ebene hinzufügen
                            const offsetX = Math.sin(data.phase) * data.radius;
                            const offsetY = Math.cos(data.phase) * data.radius;
                            // Direkte Positionsänderung (subtil!)
                            positions[i3] += offsetX * delta * 5; // Mit Delta und Faktor skalieren
                            positions[i3 + 1] += offsetY * delta * 5;

                            // Leichter Basis-Drift (auch nur wenn keine Sternschnuppe)
                             velocity.x += (Math.random() - 0.5) * particleBaseSpeed * delta * 15;
                             velocity.y += (Math.random() - 0.5) * particleBaseSpeed * delta * 15;
                             velocity.z += (Math.random() - 0.5) * particleBaseSpeed * delta * 15;
                        }


                        // 3. Position durch Velocity aktualisieren (wirkt immer)
                        positions[i3] += velocity.x * delta * 60; // Skalierung mit Delta * Framerate-Faktor
                        positions[i3 + 1] += velocity.y * delta * 60;
                        positions[i3 + 2] += velocity.z * delta * 60;

                        // 4. Dämpfung (nur wenn *keine* Sternschnuppe)
                        if (!isShootingStar) {
                             velocity.multiplyScalar(particleDamping);
                        }

                        // 5. Sternschnuppe zurücksetzen, wenn Zeit abgelaufen
                        if (isShootingStar && elapsedTime >= activeShootingStars[i]) {
                            velocity.set( // Reset auf sehr kleine Geschwindigkeit
                                (Math.random() - 0.5) * particleBaseSpeed * 2,
                                (Math.random() - 0.5) * particleBaseSpeed * 2,
                                (Math.random() - 0.5) * particleBaseSpeed * 2
                            );
                            delete activeShootingStars[i]; // Aus aktiver Liste entfernen
                        }


                        // 6. Reset wenn Partikel zu weit weg ist
                        const distSqFromCenter = positions[i3]**2 + positions[i3+1]**2 + positions[i3+2]**2;
                        const resetRadiusSq = spread * spread * 0.35; // Reset Radius etwas größer
                        if (distSqFromCenter > resetRadiusSq) {
                            // Reset näher am Zentrum
                            positions[i3] = (Math.random() - 0.5) * spread * 0.1;
                            positions[i3+1] = (Math.random() - 0.5) * spread * 0.1;
                            positions[i3+2] = (Math.random() - 0.5) * spread * 0.5; // In Z weiter streuen beim Reset
                            velocity.set( // Reset mit kleiner Geschwindigkeit
                               (Math.random() - 0.5) * particleBaseSpeed * 5,
                               (Math.random() - 0.5) * particleBaseSpeed * 5,
                               (Math.random() - 0.5) * particleBaseSpeed * 5
                            );
                            // Reset auch für individuelle Daten? Optional.
                            // data.phase = Math.random() * Math.PI * 2;
                            // Falls es eine Sternschnuppe war, aus Liste entfernen
                             if (isShootingStar) delete activeShootingStars[i];
                         }
                    }
                    particleGeometry.attributes.position.needsUpdate = true; // Wichtig!
                    // Farbattribute müssen nicht geupdated werden, außer wir ändern sie dynamisch

                    renderer.render(scene, camera);

                } catch (error) {
                     console.error("Fehler im Three.js Animations-Loop:", error);
                     if (animationFrameIdMain) cancelAnimationFrame(animationFrameIdMain);
                     animationFrameIdMain = null; threeJsInitialized = false;
                     if (threeJsCanvas) threeJsCanvas.style.display = 'none';
                }
            }

            // ===============================================================
            // ===== ENDE THREE.JS MODIFIKATIONEN ============================
            // ===============================================================


            // --- Initiale Setup Aufrufe ---
            console.log("DOM Geladen. Starte initiales Setup...");
            startIntroAnimation(); // Startet Intro & Profil Tipp-Animationen

            if (initThreeJS()) { // Versucht Three.js zu starten
                 console.log("Three.js erfolgreich initialisiert. Starte Animations-Loops.");
                 cancelAnimationFrame(animationFrameIdMain); // Sicherstellen
                 animationFrameIdMain = requestAnimationFrame(animateThreeJS); // Hauptloop

                 if (socialIcons && socialIcons.length > 0) { // Startet Social Icon Loop
                     cancelAnimationFrame(animationFrameIdSocial);
                     animationFrameIdSocial = requestAnimationFrame(updateSocialIcons);
                 } else { console.warn("Keine Social Icons gefunden."); }
            } else {
                 console.error("Three.js Initialisierung fehlgeschlagen. Partikel-Hintergrund & abhängige Animationen deaktiviert.");
            }
            console.log("Initiales Setup abgeschlossen.");

        }); // Ende DOMContentLoaded
    </script>
</body>
</html>
